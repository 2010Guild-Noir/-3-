<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<title>修羅王丸 永遠の焦土パズル</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;600;700&display=swap" rel="stylesheet">
<style>
  :root{ --bg-0:#070707; --ink:#f5f7fb; --muted:#a3a7b3; --line:#2b2e34; }
  body{ margin:0; color:var(--ink); font-family:"Noto Sans JP",system-ui,-apple-system,"Segoe UI",Roboto,"Hiragino Sans","Noto Sans JP",sans-serif;
    background: radial-gradient(1400px 680px at 50% -10%, #1b1c20 0%, #0c0c0e 55%, var(--bg-0) 100%),
               linear-gradient(180deg, #0b0b0c 0%, #09090a 100%); min-height:100dvh; text-align:center; }
  .wrap{ max-width:640px; margin:22px auto 28px; padding:16px; }
  .panel{ margin:0 auto; padding:16px 14px; border-radius:16px; background:#121316; border:1px solid var(--line);
    box-shadow:0 18px 60px rgba(0,0,0,.55), 0 1px 0 rgba(255,255,255,.06) inset; backdrop-filter:saturate(120%) blur(8px); }
  /* タイトルサイズ＝B */
  h1{ font-size:22px; letter-spacing:.03em; margin:4px 0 2px; font-weight:700; }
  .subtitle{ font-size:12.5px; color:var(--muted); margin:0 0 10px; letter-spacing:.05em; }
  .hud{ display:flex; gap:10px; justify-content:space-between; align-items:center; margin:10px 0 6px; flex-wrap:wrap; }
  .badge{ background:linear-gradient(180deg,#1c1d22,#14151a); border:1px solid var(--line); border-radius:999px; padding:8px 14px; font-weight:700; }
  .rank-progress{ font-size:12px; font-weight:400; margin-left:8px; opacity:0.8; }
canvas{ max-width:480px; box-sizing:border-box; display:block; margin:18px auto; width:100%; height:auto; aspect-ratio:1/1; box-sizing:border-box; background:#111; border-radius:14px; border:1px solid var(--line);
   box-shadow:0 16px 40px rgba(0,0,0,.6), 0 1px 0 rgba(255,255,255,.05) inset; touch-action:none; }
 .panel{ overflow:hidden; } /* はみ出しを左右均等にクリップ */
  .row{ display:flex; gap:10px; justify-content:center; flex-wrap:wrap; margin:16px 0 12px; }
  .btn{ display:inline-flex; align-items:center; gap:.4em; font-weight:600; font-size:14px;
    background:linear-gradient(180deg,#202126,#14151a); color:#fff; border:1px solid var(--line);
    border-radius:999px; padding:8px 12px; cursor:pointer; user-select:none;
    box-shadow:0 1px 0 rgba(255,255,255,.06) inset, 0 10px 24px rgba(0,0,0,.35);
    transition:transform .08s ease, box-shadow .18s ease, border-color .2s ease, background .2s ease; }
  .btn:hover{ transform:translateY(-1px); border-color:#3c4048; box-shadow:0 14px 28px rgba(0,0,0,.44); }
  .btn:active{ transform:translateY(0); box-shadow:0 6px 14px rgba(0,0,0,.44) inset; }
  .btn-kanki{ background:linear-gradient(180deg,#233246,#17212c); border-color:#2b3b4f; }
  .btn-shodo{ background:linear-gradient(180deg,#3a1b1e,#1d0e10); border-color:#4b2a2f; }
  .btn.active{ outline:2px solid #7fb7ff; }
  .btn-shuffle{ background:linear-gradient(180deg,#44224a,#2c1430); border-color:#5c3563; }
  .btn-mini{ padding:4px 8px; font-size:12px; }
  .status{ margin:6px 0 10px; font-size:12.5px; color:var(--muted); }

  /* 操作方法＝B（枠内） */
  details.help{ text-align:left; background:linear-gradient(180deg,#14151a,#111217); border:1px solid var(--line);
                border-radius:14px; padding:12px 14px; margin:14px 0; box-shadow:0 12px 32px rgba(0,0,0,.35) inset; }
  details.help summary{ cursor:pointer; font-weight:700; }
  details.help ul{ margin:8px 0 0 18px; } details.help li{ margin:4px 0; line-height:1.6; }
  small.note{ opacity:.75; display:block; margin-top:6px; }

  /* モーダル（図鑑）＝A本体 + タグ見た目はB準拠 */
  .modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.85); display: none; justify-content: center; align-items: center; z-index: 1000; }
  .modal-overlay.open { display: flex; }
  .char-modal-content { background:#191b1f; padding:25px; border-radius:12px; max-width:90%; max-height:80%; overflow-y:auto; position:relative; color:var(--ink); text-align:left; border:1px solid var(--line); box-shadow:0 12px 30px rgba(0,0,0,0.6); }
  .close-btn { position:absolute; top:10px; right:15px; font-size:28px; font-weight:bold; cursor:pointer; color:var(--muted); }
  .char-list { display:grid; grid-template-columns:repeat(auto-fit,minmax(140px,1fr)); gap:15px;margin-top:20px; }
  .char-item { border:1px solid #333; padding:10px; border-radius:8px; background:#222; opacity:5; transition:opacity .3s; }
  .char-item.unlocked{ opacity:1; }
  .char-item h4 { margin:0 0 5px 0; font-size:16px; }
  .char-item p { margin:0; font:12px; color:var(--muted); }
  .char-item img { width:40px; height:40px; margin-right:10px; border-radius:4px; vertical-align:middle; }
  .char-item .title-row { display:flex; align-items:center; }

  /* 図鑑のタグ（B準拠のサイズ/雰囲気 + 指定色） */
  .char-tag{ display:inline-block; font-size:10px; padding:3px 6px; border-radius:4px; font-weight:700; border:1px solid #444; margin-left:6px; }
  .char-tag.yellow{ background:#4d4200; border-color:#6b5e00; color:#ffd900; } /* 合歓=黄色 */
  .char-tag.blue  { background:#0c2a4a; border-color:#174a7a; color:#7fc8ff; } /* 辰十郎=青 */
  .char-tag.red   { background:#3a0c12; border-color:#5a1c22; color:#ff8a8a; } /* プロパガンダ=赤 */
  .char-tag.neutral{ background:#333; color:#ccc; }
  /* 特殊ブロック = オレンジ＋黒系 */
  .char-tag.orange{ background:#4a2a00; border-color:#6a3a00; color:#ffb25f; }

  /* 最終ランク時：特殊選択行のアイコンボタン */
  #rankSelectRow .btn-icon{
    display:inline-flex; align-items:center; gap:4px; padding:2px 4px; border-radius:10px;
    font-size:12px; line-height:0; border:1px solid var(--line); background:linear-gradient(180deg,#222,#16171b);
  }
/* 特殊選択ボタン同士の間隔を広げる（アイコンサイズや枠サイズはそのまま） */
#rankSelectRow { 
  gap: 14px;         /* ← ここでボタン間を広げます（お好みで14〜20に調整可） */
}
  #rankSelectRow .btn-icon img{ width:40px; height:40px; border-radius:3px; display:block; } /* 特殊アイコンだけ少し拡大 */
  #rankSelectRow .btn-icon.active{ outline:2px solid #7fb7ff; }

/* パネル外へ描画がはみ出さないように */
.panel{ overflow: hidden; }

/* 連続するボタン行の間を広めに */
.panel > .row + .row { margin-top: 10px; }
/* 盤面以外のボタン行は左右に広げつつ、間隔も少し広め（前回の指定を上書き） */
.panel > .row:not(#rankSelectRow) {
  justify-content: center; /* ← or flex-start。space-between をやめる */
  gap: 12px;               /* お好みの狭さに調整 */
  width: 100%;
}
details.help summary,
details.help ul,
details.help li {
  text-align: left;
}


/* === MAX Reset UI === */
#maxResetBtn{position:fixed;top:10px;right:10px;width:28px;height:28px;border-radius:9999px;border:1px solid var(--line);background:rgba(20,20,20,.85);color:var(--text);font-size:11px;line-height:28px;text-align:center;cursor:pointer;opacity:.85;display:none;z-index:9999;}
#maxResetBtn:hover{opacity:1;}
#maxResetConfirm{position:fixed;inset:0;display:none;align-items:center;justify-content:center;background:rgba(0,0,0,.45);z-index:10000;}
#maxResetConfirm .panel{background:#111;border:1px solid var(--line);border-radius:12px;padding:14px 16px;max-width:88vw;box-shadow:0 10px 28px rgba(0,0,0,.6);}
#maxResetConfirm .title{font-size:14px;margin-bottom:10px;}
#maxResetConfirm .cmds{display:flex;gap:10px;justify-content:flex-end;margin-top:8px;}
#maxResetConfirm .cmds button{font-size:13px;padding:6px 10px;border-radius:10px;border:1px solid var(--line);background:#1c1c1c;color:var(--text);cursor:pointer;}
#maxResetConfirm .cmds button.primary{background:#2a2a2a;}

</style>
</head>
<body>
  <div class="wrap">
    <div class="panel">
      <h1>修羅王丸 永遠の焦土パズル</h1>
      <p class="subtitle">3つそろえると消える—終わりなき消去と暗躍</p>

      <div class="hud">
        <div class="badge" id="score">暗躍値: 0</div> <!-- Lv表示は削除（B） -->
        <div class="badge" id="rank">修羅王丸: バース <span class="rank-progress" id="rankProgress"></span></div>
      </div>

      <canvas id="gameCanvas"></canvas>
      <!-- ★最終ランク時のみ表示：特殊ブロック選択行 -->
      <div class="row" id="rankSelectRow" style="display:none;"></div>

      <!-- ボタン列＝A -->
      <div class="row">
        <button class="btn btn-kanki" id="btnKanki" onclick="setMode('kanki'); userGesture()">歓喜</button>
        <button class="btn btn-shodo" id="btnShodo" onclick="setMode('shodo'); userGesture()">焦土</button>
        <button class="btn" id="pauseBtn" onclick="togglePause()">⏸ 一時停止</button>
        <button class="btn" id="btnCharIntro">👤 キャラ図鑑</button>
      </div>
      <div class="row">
        <button class="btn btn-mini" id="bgmSel1">♪1</button>
        <button class="btn btn-mini" id="bgmSel2">♪2</button>
        <button class="btn" id="bgmBtn" onclick="toggleBGM()">♪ BGM ON</button>
        <button class="btn" id="seBtn"  onclick="toggleSE()">🔊 SE ON</button>
      </div>

      <div class="status" id="status">status: ready</div>

      <!-- 操作方法＝B -->
      <details class="help" open>
        <summary>操作方法（PC／スマホ）</summary>
        <ul>
          <li><b>入れ替え：ブロックをドラッグ／スワイプで上下左右の隣へ。<br> 縦/横に3つ以上揃えると消去します。</li>
          <li><b>暗躍値：ブロックを消去すると暗躍値(スコア)が追加されます。<br> 中断してもスコアは引き継がれます。</li>
          <li><b>修羅王丸：修羅王丸を必要数消去すると覚醒(ランクアップ)します。<br> 覚醒最高値後は永遠の暗躍をお楽しみください。</li>
        </ul>
<small class="note"> ⚠詰んでしまったら一度ブラウザを閉じてください。盤面がシャッフルされます。</small>
      </details>

      <small class="note">Ⓒ 2010 Guild Noir. 　修羅王丸®</small>

      <!-- 図鑑モーダル＝A（タグはB風） -->
      <div id="char-modal" class="modal-overlay" onclick="if(event.target.id === 'char-modal') closeCharModal()">
        <div class="char-modal-content">
          <span class="close-btn" onclick="closeCharModal()">&times;</span>
          <h2>👤 修羅王丸 顕現図鑑</h2>
          <div id="char-list" class="char-list"></div>
        </div>
      </div>
    </div>
  </div>

  <!-- audio：音はAの構成 / クリック音 se_push / shineは別用途に温存 -->
  <audio id="bgm1" src="audio/bgm1.mp3" loop preload="auto"></audio>
  <audio id="bgm2" src="audio/bgm2.mp3" loop preload="auto"></audio>
  <audio id="se_vertical"   src="audio/se_vertical.mp3"   preload="auto"></audio>
  <audio id="se_horizontal" src="audio/se_horizontal.mp3" preload="auto"></audio>
  <audio id="se_circle"     src="audio/se_circle.mp3"     preload="auto"></audio>
  <audio id="se_cross"      src="audio/se_cross.mp3" preload="auto"></audio>
  <audio id="se_pop"        src="audio/se_pop.mp3"        preload="auto"></audio>
  <audio id="se_whoosh"     src="audio/se_whoosh.mp3" preload="auto"></audio>
  <audio id="se_shine"      src="audio/se_shine.mp3"  preload="auto"></audio>
  <audio id="se_push"       src="audio/se_push.mp3"   preload="auto"></audio> <!-- ボタン操作音 -->
  <audio id="se_bell"       src="audio/se_bell.mp3"    preload="auto"></audio>
  <audio id="se_rumble"     src="audio/se_rumble.mp3"  preload="auto"></audio>
  <audio id="vo_rank0" src="audio/vo_rank0.mp3" preload="auto"></audio>
  <audio id="vo_rank1" src="audio/vo_rank1.mp3" preload="auto"></audio>
  <audio id="vo_rank2" src="audio/vo_rank2.mp3" preload="auto"></audio>
  <audio id="vo_rank3" src="audio/vo_rank3.mp3" preload="auto"></audio>
  <audio id="vo_rank4" src="audio/vo_rank4.mp3" preload="auto"></audio>
  <audio id="vo_shuffle" src="audio/vo_shuffle.mp3" preload="auto"></audio>

<script>
"use strict";

/* ===== 永続化（A） ===== */
const store = { get(k,d){try{const v=localStorage.getItem(k);return v===null?d:JSON.parse(v);}catch(_){return d}}, set(k,v){try{localStorage.setItem(k,JSON.stringify(v));}catch(_){}} };

/* ===== サウンド（A：BGM2系統＋SEプール） ===== */
const bgm1 = document.getElementById("bgm1");
const bgm2 = document.getElementById("bgm2");
let activeBGM = store.get("activeBGM", 1) === 2 ? bgm2 : bgm1;
let bgmOn = !!store.get("bgmOn", false);

const bgmBtn = document.getElementById("bgmBtn");
const bgmSel1 = document.getElementById("bgmSel1");
const bgmSel2 = document.getElementById("bgmSel2");
const seBtn  = document.getElementById("seBtn");

const BGM_DEFAULT_VOL = 0.35;
const SE_DEFAULT_VOL  = 0.25;

function makePool(a,n){ const arr=[a]; for(let i=1;i<n;i++) arr.push(a.cloneNode(true)); let idx=0;
  return { play(v){ const e=arr[idx++%arr.length]; try{e.pause();e.currentTime=0;}catch(_){}
    e.volume=v; e.play().catch(()=>{}); } };
}
const SE_BANK = {
  vertical:document.getElementById("se_vertical"),
  horizontal:document.getElementById("se_horizontal"),
  circle:document.getElementById("se_circle"),
  cross:document.getElementById("se_cross"),
  pop:document.getElementById("se_pop"),
  whoosh:document.getElementById("se_whoosh"),
  rumble:document.getElementById("se_rumble"),
  shine:document.getElementById("se_shine"),  // shineは別用途のまま
  push:document.getElementById("se_push"),    // ボタン操作音
  bell:document.getElementById("se_bell"),
  shuffle:document.getElementById("vo_shuffle"),
};
const Sound={ enabled:store.get("seOn", true), vol:store.get("seVol", SE_DEFAULT_VOL), pools:{},
  init(){ for(const k in SE_BANK){ if(SE_BANK[k]) this.pools[k]=makePool(SE_BANK[k],6); } },
  play(n, volMul=1){ if(!this.enabled) return; const p=this.pools[n]; if(p) p.play(this.vol*volMul); },
}; Sound.init();

function setBGMVol(v){ const nv=Number(v); bgm1.volume=nv; bgm2.volume=nv; store.set("bgmVol", nv); }
function setSEVol(v){ const nv=Number(v); Sound.vol=nv; store.set("seVol", nv); }
function toggleSE(){ Sound.enabled=!Sound.enabled; seBtn.textContent=Sound.enabled?"🔊 SE ON":"🔇 SE OFF"; store.set("seOn", Sound.enabled); }

function pauseAllBGM(){ try{bgm1.pause();}catch(_){} try{bgm2.pause();}catch(_){} }
function currentBGM(){ return activeBGM===bgm2?bgm2:bgm1; }

function toggleBGM(){
  if(!bgmOn){
    pauseAllBGM(); currentBGM().currentTime = 0;
    currentBGM().play().catch(()=>{});
    bgmOn = true; bgmBtn.textContent="♪ BGM OFF";
  }else{
    pauseAllBGM(); bgmOn = false; bgmBtn.textContent="♪ BGM ON";
  }
  store.set("bgmOn", bgmOn);
}
function selectBGM(which){
  pauseAllBGM();
  activeBGM = (which===2)?bgm2:bgm1;
  store.set("activeBGM", which);
  setBGMVol(store.get("bgmVol", BGM_DEFAULT_VOL));
  activeBGM.currentTime = 0;
  activeBGM.play().then(()=>{ bgmOn=true; bgmBtn.textContent="♪ BGM OFF"; store.set("bgmOn", true); }).catch(()=>{});
  bgmSel1.classList.toggle('active', which===1);
  bgmSel2.classList.toggle('active', which===2);
}

/* 初回ジェスチャでBGM/SE解禁 */
let audioUnlocked=false;
function unlockAllSE(){
  if(audioUnlocked) return;
  audioUnlocked=true;
  for(const k in SE_BANK){
    const a=SE_BANK[k]; if(!a) continue;
    try{ const v=a.volume; a.volume=0.0001; a.play().then(()=>{ a.pause(); a.currentTime=0; a.volume=v; }).catch(()=>{ a.volume=v; }); }catch(_){}
  }
}
function userGesture(){
  unlockAllSE();
// ★タッチ/移動で必ずBGMをキック（停止中なら再生し、状態もONへ）
  if (currentBGM().paused){
    currentBGM().currentTime = 0;
    currentBGM().play()
      .then(()=>{
        bgmOn = true;
        bgmBtn.textContent = "♪ BGM OFF";
        store.set("bgmOn", true);
      })
      .catch(()=>{});
  }
}
(function initAudio(){
  setBGMVol(store.get("bgmVol", BGM_DEFAULT_VOL));
  if(!Sound.enabled) seBtn.textContent="🔇 SE OFF";
  const which=store.get("activeBGM",1);
  activeBGM = which===2?bgm2:bgm1;
  bgmSel1.classList.toggle('active', which===1);
  bgmSel2.classList.toggle('active', which===2);
  if(bgmOn){ currentBGM().play().then(()=>{ bgmBtn.textContent="♪ BGM OFF"; }).catch(()=>{}); }
  else{ pauseAllBGM(); bgmBtn.textContent="♪ BGM ON"; }
})();

/* ===== DOM & 基本設定（A 基準） ===== */
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d", { alpha:true });
const $pauseBtn = document.getElementById("pauseBtn");
const $score = document.getElementById("score");
const $rank = document.getElementById("rank");
let $rankProgress = document.getElementById("rankProgress");
const $status = document.getElementById("status");
const $charModal = document.getElementById("char-modal");
const $charList = document.getElementById("char-list");

const size = 7;
let logicalSize = 400;
let tileSize = logicalSize/size;
let DPR = Math.max(1, Math.min(3, Math.floor(window.devicePixelRatio || 1)));
let paused = false;
let isKanki = true;
const DRAG_THRESHOLD = 0.35;

/* ===== 画像（A） ===== */
const IMG = {
  "SANZU": new Image(), "MUTSU": new Image(), "HANZO": new Image(), "CHIEKO": new Image(),
  "S_BIR": new Image(), "S_NE0": new Image(), "S_SHU": new Image(), "S_REQ": new Image(), "S_UNK": new Image(),
  "J_NEM": new Image(), "J_SHI": new Image(), "J_PRO": new Image(),
  "PATH_SANZU": "images/sanzu.png",
  "PATH_MUTSU": "images/mutsu.png",
  "PATH_HANZO": "images/hanzo.png",
  "PATH_CHIEKO": "images/chieko.png",
  "PATH_S_BIR": "images/special_bir.png",
  "PATH_S_NE0": "images/special_ne0.png",
  "PATH_S_SHU": "images/special_shu.png",
  "PATH_S_REQ": "images/special_req.png",
  "PATH_S_UNK": "images/special_unk.png",
  "PATH_J_NEM": "images/nemu.png",
  "PATH_J_SHI": "images/shinjuro.png",
  "PATH_J_PRO": "images/propaganda.png",
  "BG": new Image(), "PATH_BG": "images/boad_bg.png"
};
function loadImages(done){
  let loaded=0; const keys=Object.keys(IMG).filter(k=>!k.startsWith('PATH_')); const total=keys.length;
  if(total===0){ done(); return; }
  keys.forEach(k=>{ IMG[k].onload=()=>{ if(++loaded===total) done(); }; IMG[k].onerror=()=>{ if(++loaded===total) done(); };
    const p=IMG["PATH_"+k]; if(p) IMG[k].src=p; });
}

/* ===== キャラクター図鑑 ===== */
const CHARACTERS = [
  { sym: "CHIEKO", name: "チエコ", tag: "通常", desc: "修羅王丸の最古の式神。基礎的な暗躍を担う。", image: "CHIEKO", unlock: { key: "initial" } },
  { sym: "SANZU", name: "三途", tag: "通常", desc: "修羅王丸の矛たる式神。基礎的な暗躍を担う。", image: "SANZU", unlock: { key: "initial" } },
  { sym: "HANZO", name: "ハンゾウ", tag: "通常", desc: "修羅王丸の駒たる式神。基礎的な暗躍を担う。", image: "HANZO", unlock: { key: "initial" } },
  { sym: "MUTSU", name: "陸奥怪童", tag: "通常", desc: "修羅王丸の手足たる式神。基礎的な暗躍を担う。", image: "MUTSU", unlock: { key: "initial" } },

  { sym: "S_BIR", name: "修羅王丸・バース", tag: "特殊", desc: "修羅王丸の最初の姿。縦列を消去する。", image: "S_BIR", unlock: { key: "initial" } },
  { sym: "S_NE0", name: "修羅王丸・ネオレトロ", tag: "特殊", desc: "人の姿を捨てた修羅王丸の姿。縦列消去（十字強化モードで縦列+両隣）。", image: "S_NE0", unlock: { key: "rank", value: 1 } },
  { sym: "S_SHU", name: "修羅王丸・しゅらちゃん", tag: "特殊", desc: "ネオレトロを切り捨て生まれた存在。広範囲を円形に消去する。", image: "S_SHU", unlock: { key: "rank", value: 2 } },
  { sym: "S_REQ", name: "修羅王丸・レクイエム", tag: "特殊", desc: "新たな境地を求めて生まれた存在。横列消去（十字強化モードで横列+上下隣）。", image: "S_REQ", unlock: { key: "rank", value: 3 } },
  { sym: "S_UNK", name: "修羅王丸・アンノウン", tag: "特殊", desc: "未だ見ぬ先の境地。斜め列を消去する（切り替え可能）。", image: "S_UNK", unlock: { key: "rank", value: 4 } },

  { sym: "J_NEM", name: "合歓", tag: "呪詛", desc: "修羅王丸を恨む娘。隣接する消去でHPを削る。HP:1。", image: "J_NEM", unlock: { key: "juso_spawn", value: true } },
  { sym: "J_SHI", name: "辰十郎", tag: "悔恨", desc: "筑前忍八剣衆の前元締。隣接する消去でHPを削る。HP:3。", image: "J_SHI", unlock: { key: "juso_spawn", value: true } },
  { sym: "J_PRO", name: "プロパガンダ", tag: "脅威", desc: "鏡写しの世界に住む正義の修羅王丸。隣接する消去でHPを削る。HP:5。", image: "J_PRO", unlock: { key: "juso_spawn", value: true } },
];
let unlockedChars = store.get("unlockedChars", { initial: true, juso_spawn: false });

function tagClassByChar(ch){
  // 特殊（SPECIALS 配列に含まれる）
  if (Array.isArray(SPECIALS) && SPECIALS.includes(ch.sym)) return "orange";
  // お邪魔3種（合歓・辰十郎・プロパガンダ）
  if (ch.sym === "J_NEM" || ch.sym === "J_SHI" || ch.sym === "J_PRO") return "red";
  // 通常
  return "neutral";
}
function updateCharModalContent(){
  if(!$charList) return; let html="";
  CHARACTERS.forEach(ch=>{
    let locked=false, note="";
    if(ch.unlock.key==="rank" && rankIndex<ch.unlock.value){ locked=true; note=`Rank ${ch.unlock.value} で解放`; }
    else if(ch.unlock.key==="juso_spawn" && !unlockedChars.juso_spawn){ locked=true; note=`呪詛ブロックの出現で解放`; }
    const src = IMG["PATH_"+(ch.image||ch.sym)] || "";
    const tagHtml = `<span class="char-tag ${tagClassByChar(ch)}">${ch.tag}</span>`;
    html += `<div class="char-item ${locked?'locked':'unlocked'}">
      <div class="title-row"><img src="${src}" onerror="this.style.display='none';" alt="">
        <h4>${ch.name} ${tagHtml}</h4>
      </div>
      <p>${ch.desc}</p>${locked?`<small>${note}</small>`:''}
    </div>`;
  });
  $charList.innerHTML=html;
}
function openCharModal(){ if(!paused) togglePause(); updateCharModalContent(); $charModal.classList.add("open"); }
function closeCharModal(){ $charModal.classList.remove("open"); if(paused) togglePause(); }

/* ===== ランク・種別（A） ===== */
const RANKS = [
  { key:"S_BIR", name:"バース", score: 100 },
  { key:"S_NE0", name:"ネオレトロ", score: 200 },
  { key:"S_SHU", name:"しゅらちゃん", score: 300 },
  { key:"S_REQ", name:"レクイエム", score: 400 },
  { key:"S_UNK", name:"アンノウン", score: 500 }
];
const MAX_RANK_INDEX = RANKS.length - 1;

let maxAchieved = !!store.get('maxAchieved');
let specialPerkUnlocked = !!store.get('specialPerkUnlocked');
const NORMALS=["SANZU","MUTSU","HANZO","CHIEKO"];
const SPECIALS=RANKS.map(r=>r.key);
const JUSOS=["J_NEM", "J_SHI", "J_PRO"];
const RANK_THRESH = [10, 15, 20, 25, 30];
const SPECIAL_POINTS = { "S_BIR": 20, "S_NE0": 30, "S_SHU": 40, "S_REQ": 50, "S_UNK": 60 };

let board=[], yAnim=[], score=store.get("score",0), rankIndex=store.get("rankIndex",0), rankProgress=store.get("rankProgress",0);
let slashes=[], particles=[]; // Bのエフェクト要素
let vanishMask=null, vanishP=0, animState="idle";
let drag={active:false,start:null,t:null}, swapPair=null;
let jusoHP=[], currentObstacleCount=0;

/* === 最終ランク：特殊ブロック選択 === */
let selectedSpecialOverride = null; // null時は通常のランク依存
function voiceForSpecial(sym){
  if(sym==="S_BIR") return document.getElementById("vo_rank0");
  if(sym==="S_NE0") return document.getElementById("vo_rank1");
  if(sym==="S_SHU") return document.getElementById("vo_rank2");
  if(sym==="S_REQ") return document.getElementById("vo_rank3");
  if(sym==="S_UNK") return document.getElementById("vo_rank4");
  return null;
}
// ★追加：再生中のランクボイスを止める
function stopAllRankVoices(){
  ["vo_rank1","vo_rank2","vo_rank3","vo_rank4"].forEach(id=>{
    const a = document.getElementById(id);
    if(a){ try{ a.pause(); a.currentTime = 0; }catch(_){} }
  });
}

function buildRankSelectButtons(){
  const row = document.getElementById('rankSelectRow');
  if(!row || row.dataset.built==="1") return;
  const specials = ["S_BIR","S_NE0","S_SHU","S_REQ","S_UNK"];
  specials.forEach(sym=>{
    const btn = document.createElement('button');
    btn.className = 'btn-icon';
    const img = document.createElement('img');
    img.src = IMG["PATH_"+sym] || "";
    img.alt = sym;
    btn.appendChild(img);
    btn.addEventListener('click', ()=>{
      if(rankIndex!==MAX_RANK_INDEX) return;
      selectedSpecialOverride = sym;
      [...row.children].forEach(el=>el.classList.remove('active'));
      btn.classList.add('active');

      stopAllRankVoices();              // ★追加：前のボイスを停止
      const v = voiceForSpecial(sym);
      if(v){ try{ v.currentTime=0; v.play().catch(()=>{}); }catch(_){} }

      Sound.play('push', .9);
    });
    row.appendChild(btn);
  });
  row.dataset.built="1";
}

function updateStatus(text){ if($status) $status.textContent=text; }
function updateScoresUI(){
  // 暗躍値：B（Lvは出さない）
  $score.textContent = `暗躍値: ${score}`;
  // 右上ランク（A）
  const label = `修羅王丸: ${RANKS[rankIndex].name} `;
  if ($rank.firstChild) $rank.firstChild.textContent = label; else $rank.textContent = label;
  $rankProgress = document.getElementById("rankProgress") || (()=>{
    const sp=document.createElement('span'); sp.className='rank-progress'; sp.id='rankProgress'; $rank.appendChild(sp); return sp;
  })();
  $rankProgress.textContent = rankIndex===MAX_RANK_INDEX ? 'MAX' : `(${rankProgress}/${RANK_THRESH[rankIndex]})`;
  // 最終ランクで選択行を表示
  const selRow = document.getElementById('rankSelectRow');
  if(selRow){
    if(rankIndex===MAX_RANK_INDEX){
      buildRankSelectButtons();
      selRow.style.display='';
    }else{
      selRow.style.display='none';
      selectedSpecialOverride=null;
      [...selRow.children].forEach(el=>el.classList.remove('active'));
    }
  }
  // 永続
  store.set("score",score); store.set("rankIndex",rankIndex); store.set("rankProgress",rankProgress);

  try{ if(window.__gateMaxResetBtn) window.__gateMaxResetBtn(); }catch(_){ }
}

/* ===== 盤面（A） ===== */
function get(r,c){ return (r>=0 && r<size && c>=0 && c<size) ? board[r][c] : null; }
function set(r,c,v){ if(r>=0 && r<size && c>=0 && c<size) board[r][c]=v; }
function swap(r1,c1,r2,c2){ [board[r1][c1],board[r2][c2]]=[board[r2][c2],board[r1][c1]]; }
function getInitialBlock(){ return NORMALS[Math.floor(Math.random()*NORMALS.length)]; }

function initBoard(){
  board = Array.from({length:size},()=>Array(size).fill(0));
  jusoHP= Array.from({length:size},()=>Array(size).fill(0));
  yAnim = Array.from({length:size},()=>Array(size).fill(0));
  yVel  = Array.from({length:size},()=>Array(size).fill(0)); /* ★クッション用 速度配列 */
  for(let r=0;r<size;r++){
    for(let c=0;c<size;c++){
      let b;
      do{ b=getInitialBlock(); }
      while((c>=2 && get(r,c-1)===b && get(r,c-2)===b) || (r>=2 && get(r-1,c)===b && get(r-2,c)===b));
      set(r,c,b);
    }
  }
  currentObstacleCount=0;
  prepareDrop();
}

/* ===== 入力（A） ===== */
function getGridPos(x,y){
  const rect=canvas.getBoundingClientRect(), nx=x-rect.left, ny=y-rect.top;
  const scale = logicalSize/rect.width;
  const gc=Math.floor(nx*scale/tileSize), gr=Math.floor(ny*scale/tileSize);
  if(gc<0||gc>=size||gr<0||gr>=size) return null;
  return {r:gr,c:gc};
}
function onStart(x,y){
  userGesture();
  if (paused || animState !== "idle" || swapPair) return;
  const pos=getGridPos(x,y); if(pos){ drag.active=true; drag.start=pos; drag.t={...pos,px:x,py:y}; }
}
function onMove(x,y){
  if(!drag.active || !drag.t) return;
  const rect=canvas.getBoundingClientRect(), scale=logicalSize/rect.width;
  const distSq=(x-drag.t.px)**2+(y-drag.t.py)**2;
  if(distSq<(tileSize*0.35/scale)**2) return;
  const dx=x-drag.t.px, dy=y-drag.t.py;
  let dirX=0, dirY=0;
  if(Math.abs(dx)>Math.abs(dy)) dirX=dx>0?1:-1; else dirY=dy>0?1:-1;
  const {r,c}=drag.start, nr=r+dirY, nc=c+dirX;
  if(nr>=0 && nr<size && nc>=0 && nc<size){
    if (JUSOS.includes(get(r,c)) || JUSOS.includes(get(nr,nc))) return; // ★お邪魔は動かさない
    drag.active=false; swapAndStart(r,c,nr,nc);
  }
}
function onEnd(){ drag.active=false; drag.start=null; drag.t=null; }

/* ===== モード・一時停止（A） ===== */
function setMode(mode){
  isKanki=(mode==='kanki');
  document.getElementById("btnKanki").classList.toggle("active",isKanki);
  document.getElementById("btnShodo").classList.toggle("active",!isKanki);
  updateStatus(`status: モードを「${isKanki?'歓喜':'焦土'}」に設定しました。`);
}
function togglePause(){ paused=!paused; $pauseBtn.textContent=paused?"▶ 再開":"⏸ 一時停止"; if(!paused) gameLoop(); }

/* ===== マッチ判定～消去（Aロジック＋Bエフェクト） ===== */
let lastMatchVH={v:false,h:false};
function findMatches(checkOnly=true){
  lastMatchVH={v:false,h:false};
  const matches=new Set(); const isBlocked=(b)=> JUSOS.includes(b) || b===null;
  // 縦
  for(let c=0;c<size;c++) for(let r=0;r<=size-3;r++){
    const b=get(r,c); if(isBlocked(b)) continue;
    let len=1; for(let i=r+1;i<size;i++){ if(get(i,c)===b) len++; else break; }
    if(len>=3){ for(let i=0;i<len;i++) matches.add(`${r+i},${c}`); r+=len-1; lastMatchVH.v=true; }
  }
  // 横
  for(let r=0;r<size;r++) for(let c=0;c<=size-3;c++){
    const b=get(r,c); if(isBlocked(b)) continue;
    let len=1; for(let i=c+1;i<size;i++){ if(get(r,i)===b) len++; else break; }
    if(len>=3){ for(let i=0;i<len;i++) matches.add(`${r},${c+i}`); c+=len-1; lastMatchVH.h=true; }
  }

  if(checkOnly) return matches.size>0;
  if(matches.size>0){
    vanishMask = matches; animState="vanish"; vanishP=0;
    // 消去SE（A）
    Sound.play('pop',1.0);
    if(lastMatchVH.v) Sound.play('vertical', .9);
    if(lastMatchVH.h) Sound.play('horizontal', .9);
    // エフェクト生成（B風：斬撃＋粒子）
    createSlashEffects(matches);
    createParticles(matches);
    return true;
  }
  return false;
}

/* ランク進捗・ボイス（A） */
function updateRank(){
  // Post-top progress handling
  if(rankIndex===MAX_RANK_INDEX){
    if(!maxAchieved && rankProgress>=RANK_THRESH[rankIndex]){
      rankProgress = RANK_THRESH[rankIndex];
      maxAchieved = true; store.set('maxAchieved', true);
      specialPerkUnlocked = true; store.set('specialPerkUnlocked', true);
      try{ Sound.play('bell', 1.0); }catch(_){}
      try{ const v=document.getElementById('vo_rank5'); if(v){ v.volume=1.0; v.play().catch(()=>{}); } }catch(_){}
    }
    if(rankProgress>RANK_THRESH[rankIndex]) rankProgress = RANK_THRESH[rankIndex];
  }

  if(rankIndex<MAX_RANK_INDEX && rankProgress>=RANK_THRESH[rankIndex]){
    rankProgress=0; rankIndex++;
    const v = document.getElementById(`vo_rank${Math.min(rankIndex,4)}`);
    if(v){ try{ v.currentTime=0; v.play().catch(()=>{}); }catch(_){} }
    Sound.play('bell', 1.0); // ランクアップ時、鐘を同時再生
  }
  if(rankIndex>=1 && !unlockedChars.juso_spawn){ unlockedChars.juso_spawn=true; store.set("unlockedChars", unlockedChars); }
  updateScoresUI();
      }

/* 消去→落下（A：下へ圧縮→上から補充） */
const SEED_BASE_CHANCE = 0.06;

// === 特殊ギミック用ユーティリティ ===
function addCell(set, r, c){
  if(r>=0 && r<size && c>=0 && c<size) set.add(`${r},${c}`);
}
function applySpecialGimmicks(baseMatches){
  const extra = new Set();
  baseMatches.forEach(pos=>{
    const [r,c]=pos.split(',').map(Number);
    const b=get(r,c);
    if(!b || !SPECIALS.includes(b)) return;

    if(b==="S_BIR"){ // 縦列
      for(let rr=0; rr<size; rr++) addCell(extra, rr, c);
    }
    else if(b==="S_NE0"){ // 縦列 (+焦土で両隣の列)
      for(let rr=0; rr<size; rr++) addCell(extra, rr, c);
      if(!isKanki){ for(let rr=0; rr<size; rr++){ addCell(extra, rr, c-1); addCell(extra, rr, c+1); } }
    }
    else if(b==="S_SHU"){ // 円形（半径2）
      for(let rr=r-2; rr<=r+2; rr++) for(let cc=c-2; cc<=c+2; cc++){
        const dx=cc-c, dy=rr-r;
        if(dx*dx+dy*dy<=4) addCell(extra, rr, cc);
      }
    }
    else if(b==="S_REQ"){ // 横列 (+焦土で上下の行)
      for(let cc=0; cc<size; cc++) addCell(extra, r, cc);
      if(!isKanki){ for(let cc=0; cc<size; cc++){ addCell(extra, r-1, cc); addCell(extra, r+1, cc); } }
    }
    else if(b==="S_UNK"){ // 斜め×2
      for(let k=-size; k<=size; k++){
        addCell(extra, r+k, c+k);
        addCell(extra, r+k, c-k);
      }
    }
  });
  return extra;
}

function resolveVanishAndDrop(){
  if(!vanishMask) return;

  // 今回消えた特殊の種類を収集→専用SE
  const specialsHit = new Set();
  vanishMask.forEach(pos=>{
    const [r,c] = pos.split(',').map(Number);
    const b = get(r,c);
    if (b && SPECIALS.includes(b)) specialsHit.add(b);
  });
  specialsHit.forEach(sym=>{
    if (sym==="S_BIR" || sym==="S_NE0")      Sound.play('vertical', 0.9);
    else if (sym==="S_REQ")                  Sound.play('horizontal', 0.9);
    else if (sym==="S_SHU")                  Sound.play('circle', 1.0);
    else if (sym==="S_UNK")                  Sound.play('cross', 1.0);
  });

  // ① 特殊ギミックで追加セルを拡張
  const extra = applySpecialGimmicks(vanishMask);
  extra.forEach(p=> vanishMask.add(p));
  if (extra.size) { createSlashEffects(extra); createParticles(extra); }

  // ② スコア加算・HP処理・実セル消去
  vanishMask.forEach(pos=>{
    const [r,c]=pos.split(',').map(Number);
    const b=get(r,c);
    if(b){
      score += 10;
      if(SPECIALS.includes(b)){
        score += SPECIAL_POINTS[b];
      }
    }
    // 周囲のお邪魔にダメージ
    for(let dr=-1; dr<=1; dr++){
      for(let dc=-1; dc<=1; dc++){
        if(!dr && !dc) continue;
        const tr=r+dr, tc=c+dc;
        if(JUSOS.includes(get(tr,tc)) && jusoHP[tr][tc]>0){
          jusoHP[tr][tc]--;
          if (jusoHP[tr][tc]===0){
            set(tr,tc,null);
            jusoHP[tr][tc] = 0;
            score += 100;
            Sound.play('vertical');
          } else {
            Sound.play('rumble');
          }
        }
      }
    }
    if (JUSOS.includes(b)) {
      /* obstacle: keep until HP zero via adjacency */
    } else {
      set(r,c,null);
    }
  });

// ★追加：この消去で一度でも特殊ブロックが含まれていれば「回数」として1加算
  if (specialsHit.size > 0) {
    if(!(rankIndex===MAX_RANK_INDEX && maxAchieved)) rankProgress++;
  }

  // ③ ランク更新（ここでボイス＋se_bell が鳴る実装済み）
  const prevRank = rankIndex;
  updateRank();

  // ④ ランクアップ時：盤面全消去（縦ギミック演出）
  if(rankIndex > prevRank){
    const all = new Set();
    for(let r=0;r<size;r++){
      for(let c=0;c<size;c++){
        if(get(r,c)!==null) all.add(`${r},${c}`);
      }
    }
    if(all.size>0){
      vanishMask = all;
      animState = "vanish";
      vanishP = 0;
      lastMatchVH.v = true;  // 縦斬撃の雰囲気
      lastMatchVH.h = false;
      createSlashEffects(all);
      return; // 演出後に再度 resolve が走る
    }
  }

  // ⑤ 通常どおり落下へ
  vanishMask = null;
  prepareDrop();
  animState = "drop";
  maybeSpawnObstacles();
}

/* ★クッション落下用の速度配列と定数 */
let yVel = [];
const GRAVITY = 0.045; // tileSize 倍は毎フレーム動的に加味
const BOUNCE  = 0.25;
const VEL_EPS = 0.6;

function prepareDrop(){
  // 下圧縮
  for(let c=0;c<size;c++){
    let empty=size-1;
    for(let r=size-1;r>=0;r--){
      const b=get(r,c);
      if(b!==null){
        if(r!==empty){
          set(empty,c,b); set(r,c,null);
          if (!jusoHP[empty]) jusoHP[empty] = [];
          if (!jusoHP[r])     jusoHP[r]     = [];
          jusoHP[empty][c] = jusoHP[r][c] || 0;
          jusoHP[r][c] = 0;
          if(!yAnim[empty]) yAnim[empty]=[];
          if(!yVel[empty])  yVel[empty] =[];
          yAnim[empty][c] = -(empty-r)*tileSize;
          yVel[empty][c]  = 0; // ★新位置の速度をリセット
          if(!yVel[r]) yVel[r]=[];
          yVel[r][c]=0;        // ★元位置の速度も0
        }
        empty--;
      }
    }
  }
  // 上から補充
  for(let c=0;c<size;c++){
    let emptyCount=0;
    for(let r=0;r<size;r++) if(get(r,c)===null) emptyCount++;
    for(let r=0;r<emptyCount;r++){
      let nb=getInitialBlock();
      if(Math.random()<SEED_BASE_CHANCE){
        nb = (specialPerkUnlocked && selectedSpecialOverride)
             ? selectedSpecialOverride
             : SPECIALS[Math.min(rankIndex, SPECIALS.length-1)];
        Sound.play('shine', 0.7);   // 特殊出現音
      }
      set(r,c,nb);
      if (!jusoHP[r]) jusoHP[r] = [];
      jusoHP[r][c] = 0;
      if(!yAnim[r]) yAnim[r]=[];
      if(!yVel[r])  yVel[r] =[];
      yAnim[r][c] = -(emptyCount-r)*tileSize;
      yVel[r][c]  = 0; // ★新規生成も速度0から
    }
    for(let r=emptyCount;r<size;r++){
      if(!yAnim[r]) yAnim[r]=[];
      if(!yVel[r])  yVel[r] =[];
      yAnim[r][c] = yAnim[r][c] || 0;
      yVel[r][c]  = yVel[r][c]  || 0;
    }
  }
  Sound.play('whoosh',0.6);
}

/* お邪魔生成（A） */
function maybeSpawnObstacles(){
  if(rankIndex<1) return;
  if(Math.random()>0.16) return; //お邪魔ブロックの出現率を2倍に
  const n = 1 + (Math.random()<0.35?1:0);
  let k=0, guard=100;
  while(k<n && guard--){
    const r=Math.floor(Math.random()*size), c=Math.floor(Math.random()*size);
    const cur=get(r,c); if(!cur || JUSOS.includes(cur)) continue;
    const pool = ["J_NEM", "J_SHI", "J_PRO"];
    const pick = pool[Math.floor(Math.random()*pool.length)];
    set(r,c,pick); if(!jusoHP[r]) jusoHP[r]=[]; jusoHP[r][c]=(pick==="J_NEM"?1:(pick==="J_SHI"?2:3)); k++;
  }
}

/* 斬撃＆粒子エフェクト（B風味） */
function createSlashEffects(matches){
  slashes=[];
  matches.forEach(p=>{
    const [r,c]=p.split(',').map(Number);
    const cx=c*tileSize+tileSize/2, cy=r*tileSize+tileSize/2;
    slashes.push({x:cx,y:cy,dir:'h',t:0});
    slashes.push({x:cx,y:cy,dir:'v',t:0});
  });
}
function createParticles(matches){
  particles=[];
  matches.forEach(p=>{
    const [r,c]=p.split(',').map(Number);
    const cx=c*tileSize+tileSize/2, cy=r*tileSize+tileSize/2;
    for(let i=0;i<size;i++){
      particles.push({
        x:cx, y:cy,
        vx:(Math.random()-0.5)*tileSize*0.18,
        vy:(Math.random()-0.5)*tileSize*0.18,
        life:0, maxLife:18
      });
    }
  });
}

/* 描画（盤面はA、BG敷き詰め、エフェクトはB色分け） */
const SWAP_ANIM_TIME=0.15*60, VANISH_ANIM_TIME=0.25*60;
function drawSlashes(){
  if(!slashes.length) return;
  ctx.save();
  // モード色
  ctx.strokeStyle = isKanki ? "rgba(255,255,255,0.8)" : "rgba(200,40,40,0.85)";
  ctx.globalCompositeOperation='lighter';
  for(const s of slashes){
    const t=Math.min(1,s.t); const len=tileSize*(1+t*1.2); const w=Math.max(2,6-t*5);
    ctx.lineWidth=w; ctx.beginPath();
    if(s.dir==='h'){ ctx.moveTo(s.x-len,s.y); ctx.lineTo(s.x+len,s.y); }
    else{ ctx.moveTo(s.x,s.y-len); ctx.lineTo(s.x,s.y+len); }
    ctx.stroke(); s.t+=0.12;
  }
  slashes=slashes.filter(s=>s.t<1.0); ctx.restore();
}
function drawParticles(){
  if(!particles.length) return;
  ctx.save();
  ctx.globalCompositeOperation='lighter';
  for(const p of particles){
    const t=p.life/p.maxLife;
    const alpha = isKanki ? (0.8*(1-t)) : (0.9*(1-t));
    ctx.fillStyle = isKanki ? `rgba(180,220,255,${alpha})` : `rgba(220,40,40,${alpha})`;
    const rad = Math.max(1, 3 - 2*t);
    ctx.beginPath(); ctx.arc(p.x, p.y, rad, 0, Math.PI*2); ctx.fill();
    p.x += p.vx; p.y += p.vy; p.vy += 0.05; p.life++;
  }
  particles=particles.filter(p=>p.life<p.maxLife);
  ctx.restore();
}

function drawBlock(r,c,x,y,a=1){
  const b=get(r,c); if(b===null) return;
  ctx.save(); ctx.globalAlpha=a;
  const img=IMG[b]; const s=tileSize*0.9, off=tileSize*0.05;
  if(img&&img.complete) ctx.drawImage(img,x+off,y+off,s,s);
  else{ ctx.fillStyle='#444'; ctx.fillRect(x,y,tileSize,tileSize); }
  if (JUSOS.includes(b) && jusoHP[r][c] > 0) {
    ctx.fillStyle = 'rgba(255,255,255,0.9)';
    ctx.font = `bold ${tileSize * 0.3}px sans-serif`;
    // 右下表示
    ctx.textAlign = 'right';
    ctx.textBaseline = 'alphabetic';
    const pad = tileSize * 0.08;
    ctx.fillText(jusoHP[r][c], x + tileSize - pad, y + tileSize - pad);
  }
  ctx.restore();
}

function drawGame(){
  ctx.clearRect(0,0,logicalSize,logicalSize);
  // BG（Aの駒枠式爪）敷き詰め
  const bg=IMG.BG; if(bg&&bg.complete&&bg.naturalWidth>0){
    for(let r=0;r<size;r++) for(let c=0;c<size;c++){
      ctx.drawImage(bg,0,0,bg.naturalWidth,bg.naturalHeight,c*tileSize,r*tileSize,tileSize,tileSize);
    }
  }
  // 焦土フィルター（薄赤黒）
  if(!isKanki){ ctx.save(); ctx.fillStyle='rgba(60,0,0,0.22)'; ctx.fillRect(0,0,logicalSize,logicalSize); ctx.restore(); }

  for(let r=0;r<size;r++) for(let c=0;c<size;c++){
    if(get(r,c)===null) continue;
    let x=c*tileSize, y=r*tileSize, a=1, ty=0;
    if(animState==="vanish" && vanishMask && vanishMask.has(`${r},${c}`)) a = 1-vanishP;
    if(animState==="drop" && yAnim[r][c]!==0) ty = yAnim[r][c];
    if(animState==="swap" && swapPair){
      const {p1,p2,p,back}=swapPair; const prog=Math.min(1,p/(SWAP_ANIM_TIME)), e=Math.sin(prog*Math.PI/2);
      if(r===p1.r&&c===p1.c){ x+=(back?(p2.c-p1.c)*tileSize*(1-e):(p2.c-p1.c)*tileSize*e);
                               y+=(back?(p2.r-p1.r)*tileSize*(1-e):(p2.r-p1.r)*tileSize*e); }
      if(r===p2.r&&c===p2.c){ x+=(back?(p1.c-p2.c)*tileSize*(1-e):(p1.c-p2.c)*tileSize*e);
                               y+=(back?(p1.r-p2.r)*tileSize*(1-e):(p1.r-p2.r)*tileSize*e); }
    }
    drawBlock(r,c,x,y+ty,a);
  }
  // B風：斬撃＆粒子
  drawSlashes();
  drawParticles();

  // 前面スワップ（A）
  if(animState==="swap" && swapPair){
    const {p1,p2,p,back}=swapPair; const prog=Math.min(1,p/(SWAP_ANIM_TIME)), e=Math.sin(prog*Math.PI/2);
    let x1=p1.c*tileSize+(back?(p2.c-p1.c)*tileSize*(1-e):(p2.c-p1.c)*tileSize*e);
    let y1=p1.r*tileSize+(back?(p2.r-p1.r)*tileSize*(1-e):(p2.r-p1.r)*tileSize*e);
    drawBlock(p1.r,p1.c,x1,y1,1);
    let x2=p2.c*tileSize+(back?(p1.c-p2.c)*tileSize*(1-e):(p1.c-p2.c)*tileSize*e);
    let y2=p2.r*tileSize+(back?(p1.r-p2.r)*tileSize*(1-e):(p1.r-p2.r)*tileSize*e);
    drawBlock(p2.r,p2.c,x2,y2,1);
  }
}

/* スワップ～ループ（A） */
function canSwapAndMatch(r1,c1,r2,c2){
  if(JUSOS.includes(get(r1,c1))||JUSOS.includes(get(r2,c2))) return false;
  swap(r1,c1,r2,c2);
  const has = !!findMatches(true);
  swap(r1,c1,r2,c2);
  return has;
}
function swapAndStart(r1,c1,r2,c2){
  swapPair={p1:{r:r1,c:c1},p2:{r:r2,c:c2},p:0,back:false};
  animState="swap";
  userGesture();
}
function gameLoop(){
  if(paused) return;
  drawGame();
  switch(animState){
    case "swap":
      if(swapPair){
        swapPair.p++;
        if(swapPair.p>=SWAP_ANIM_TIME){
          const {p1,p2,back}=swapPair;
          if(!back){
            swap(p1.r,p1.c,p2.r,p2.c);
            if(findMatches(true)){ findMatches(false); swapPair=null; animState="vanish"; }
            else{ swap(p1.r,p1.c,p2.r,p2.c); swapPair.p=0; swapPair.back=true; }
          }else{ swapPair=null; animState="idle"; }
        }
      }
      break;
    case "vanish":
      vanishP += (1/VANISH_ANIM_TIME); if(vanishP>=1){ resolveVanishAndDrop(); }
      break;
    case "drop":
      // ★クッション落下：重力＋弱い反発でやわらかく停止
      let done=true;
      for(let r=0;r<size;r++) for(let c=0;c<size;c++){
        if(yAnim[r][c]!==0 || yVel[r][c]!==0){
          const g = GRAVITY*tileSize;     // 盤面サイズに依存させる
      yVel[r][c] += g;          // 加速
      yVel[r][c] *= 0.88;       // ★減衰でふわっと
      // オーバーシュートさせずにそのまま着地
      if (yAnim[r][c] + yVel[r][c] >= 0){
        yAnim[r][c] = 0;
        yVel[r][c]  = 0;
      } else {
        yAnim[r][c] += yVel[r][c];
      }
          if(yAnim[r][c]!==0 || yVel[r][c]!==0) done=false;
        }
      }
      if(done){
        if(findMatches(true)){ findMatches(false); animState="vanish"; }
        else { animState="idle"; }
      }
      break;
  }
  requestAnimationFrame(gameLoop);
}

/* シャッフル（A：手動のみ） */
function hasPossibleMoves(){
  for(let r=0;r<size;r++) for(let c=0;c<size;c++){
    if(c+1<size && canSwapAndMatch(r,c,r,c+1)) return true;
    if(r+1<size && canSwapAndMatch(r,c,r+1,c)) return true;
  }
  return false;
}
function shuffleBoard(){
  const maxTries=300; let tries=0;
  do{
    const flat=board.flat(); for(let i=flat.length-1;i>0;i++){ const j=Math.floor(Math.random()*(i+1)); [flat[i],flat[j]]=[flat[j],flat[i]]; }
    for(let r=0,k=0;r<size;r++) for(let c=0;c<size;c++,k++) board[r][c]=flat[k];
    tries++;
  }while((findMatches(true)||!hasPossibleMoves()) && tries<maxTries);
  updateStatus("status: 盤面をシャッフルしました。");
  animState="drop"; prepareDrop();
}

/* 起動（A） */
function initGame(reset=false){
const parentW = 480;                      // ★固定サイズに
  logicalSize = Math.floor(480/size)*size;  // ★盤面ロジックも固定
  tileSize = logicalSize/size;
  DPR=Math.max(1,Math.min(3,Math.floor(window.devicePixelRatio||1)));
  canvas.width=logicalSize*DPR; canvas.height=logicalSize*DPR; ctx.setTransform(1,0,0,1,0,0); ctx.scale(DPR,DPR);
  canvas.style.width = '100%'; canvas.style.height = 'auto';
  if(reset) initBoard();
  updateScoresUI();
      setMode('kanki');
  if(!reset) gameLoop();
}
function startUp(){ loadImages(()=>{ initGame(true); updateStatus("status: game loaded. ready to play."); gameLoop(); }); }

/* イベント（Aのまま。ボタンSEは se_push に統一） */
const onClickSE = ()=>Sound.play('push', .9);
canvas.addEventListener('mousedown',e=>onStart(e.clientX,e.clientY));
canvas.addEventListener('mousemove',e=>onMove(e.clientX,e.clientY));
canvas.addEventListener('mouseup',onEnd);
canvas.addEventListener('mouseleave',onEnd);
canvas.addEventListener('touchstart',e=>{ e.preventDefault(); onStart(e.touches[0].clientX,e.touches[0].clientY); });
canvas.addEventListener('touchmove',e=>{ e.preventDefault(); onMove(e.touches[0].clientX,e.touches[0].clientY); });
canvas.addEventListener('touchend',onEnd);

document.getElementById("btnCharIntro").addEventListener('click', ()=>{ onClickSE(); openCharModal(); });
document.querySelectorAll('.btn').forEach(b=>{
  if(b.id!=="shuffleBtn"){ b.addEventListener('click', onClickSE); }
});
bgmSel1.addEventListener('click', ()=>selectBGM(1));
bgmSel2.addEventListener('click', ()=>selectBGM(2));

window.addEventListener('beforeunload', ()=>{
  store.set("score",score); store.set("rankIndex",rankIndex); store.set("rankProgress",rankProgress);
});

startUp();
</script>
  <audio id="vo_reverse" src="audio/vo_reverse.mp3" preload="auto"></audio>
  <audio id="vo_rank5" src="audio/vo_rank5.mp3" preload="auto"></audio>

<div id="maxResetBtn" title="MAXをリバース">↺</div>
<div id="maxResetConfirm" role="dialog" aria-modal="true">
  <div class="panel">
    <div class="title">修羅王丸の覚醒ランクをリバースしますか</div>
    <div class="cmds">
      <button id="maxResetNo">いいえ</button>
      <button id="maxResetYes" class="primary">はい</button>
    </div>
  </div>
</div>

<script>
(function(){
  const $btn = document.getElementById('maxResetBtn');
  const $dlg = document.getElementById('maxResetConfirm');
  const $yes = document.getElementById('maxResetYes');
  const $no  = document.getElementById('maxResetNo');
  function gateMaxResetBtn(){
    if(!$btn) return;
    if(typeof rankIndex!=='undefined' && typeof MAX_RANK_INDEX!=='undefined' && typeof maxAchieved!=='undefined'){
      $btn.style.display = (rankIndex===MAX_RANK_INDEX && maxAchieved) ? '' : 'none';
    }
  }
  if($btn){ $btn.addEventListener('click', ()=>{ if($dlg) $dlg.style.display='flex'; }); }
  if($no){ $no.addEventListener('click', ()=>{ if($dlg) $dlg.style.display='none'; }); }
  if($yes){
    $yes.addEventListener('click', ()=>{
      try{
        maxAchieved = false; if(store&&store.set){ store.set('maxAchieved', false); }
        rankIndex = 0; rankProgress = 0;
        if(store&&store.set){ store.set('rankIndex',0); store.set('rankProgress',0); }
        updateScoresUI();
        try{ const v=document.getElementById('vo_reverse'); if(v){ v.currentTime=0; v.volume=1.0; v.play().catch(()=>{}); } }catch(_){}
      try{ Sound.play('cancel', 0.8); }catch(_){}
        }catch(e){}
      if($dlg) $dlg.style.display='none';
      gateMaxResetBtn();
    });
  }
  window.__gateMaxResetBtn = gateMaxResetBtn;
})();</script>
</body>
</html>
